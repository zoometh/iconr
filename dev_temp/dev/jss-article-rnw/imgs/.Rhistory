# loop through rows selecting on subset df by num
# r <- 8
field_num <- str.bulk.select[str.bulk.select$num == r,"num"]
rcu_entite <- str.bulk.select[str.bulk.select$num == r,"rcu_entite"]
rcu_onglet <- str.bulk.select[str.bulk.select$num == r,"rcu_onglet"]
rcu_field_name <- str.bulk.select[str.bulk.select$num == r,"rcu_field_name"]
rcu_field_num <- str.bulk.select[str.bulk.select$num == r,"rcu_field_num"]
ucop_field_name <- str.bulk.select[str.bulk.select$num == r,"ucop_field_name"]
ucop_pattern <- str.bulk.select[str.bulk.select$num == r,"ucop_pattern"]
ucop_spec_funct <- str.bulk.select[str.bulk.select$num == r,"spec_funct"]
# messages
#print(cat(paste0(rep(espace,1)),rcu_entite))
print(cat(paste0(rep(espace,1)),corresp.ws))
print(cat(paste0(rep(espace,2)),field_num))
print(cat(paste0(rep(espace,3)),rcu_onglet))
print(cat(paste0(rep(espace,5)),rcu_field_name))
print(cat(paste0(rep(espace,5)),rcu_field_num))
print(cat(paste0(rep(espace,7)),ucop_spec_funct)) # special function
### apply the hub function - - - - - - - - - - - -
### UCOP
## Features
if(nme.bulk == '_Features'){
#dt.all <- head(oss.all.vZ,5)
#
# df.version <- paste0("oss.all.",bulk.from.version)
# exp.read.df.version <- paste0("dt.all <- ",df.version)
# eval(parse(text=exp.read.df.version)) # create 'dt.all'
CopyInfos(corresp.ws,out.blk,dt.all,
rcu_entite,rcu_onglet,rcu_field_name,rcu_field_num,
ucop_field_name,ucop_pattern,ucop_spec_funct)
}
## UCOP Archaeological Finds
if(nme.bulk == '_Archaeological_Finds' & corresp.ws == 'obj.UCOP'){
# for UCOP survey
dt.all <- f.ucop_archaeological_finds()  # appropriate format
CopyInfos(corresp.ws,out.blk,dt.all,
rcu_entite,rcu_onglet,rcu_field_name,rcu_field_num,
ucop_field_name,ucop_pattern,ucop_spec_funct)
print(cat("DONE ",paste0(rep(espace,20))))
}
### DDN
## DDN Archaeological Finds
if(nme.bulk == '_Archaeological_Finds' & corresp.ws == 'obj.DDN'){
# for DDN survey
# dt.all <- objects.idiha.ddn
CopyInfos(corresp.ws,out.blk,dt.all,
rcu_entite,rcu_onglet,rcu_field_name,rcu_field_num,
ucop_field_name,ucop_pattern,ucop_spec_funct)
print(cat("DONE ",paste0(rep(espace,20))))
}
}
# add a pattern in the sheet "zzAssessment" or "zzzAssessment"
if(nme.bulk == '_Features'){aMotifSupp(out.blk,"zzAssessment")}
if(nme.bulk == '_Archaeological_Finds'){aMotifSupp(out.blk,"zzzAssessment")}
#if(nme.bulk %in% c('_Features','_Archaeological_Finds')){aMotifSupp(out.blk,"zzAssessment")}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# TODO: VULNERABILITY_TYPE.E55 double certaines valeurs
# TODO: DISTURBANCE_CAUSE_TYPE.I4
# output bulk with corresponding rows - - - - - - - - - - - -
# select by version or loc, worksheet, rcu_entite and rows in the bulk correspondances
# oss.all.vZ <- f.layout(reload.bd,vZ) # layout
# oss.all.vZ <- head(oss.all.vZ,50) # sample
## Some sublist of fields
NameGroup.num <- c(5:6) # util for Features nb pipes checking
Feat.Assmt <- c(1:4) # check assesment data
Feat.NoGeom.blk <- c(1:8,11:73) # all bulk without Geometries (time cost)
Feat.Sign.blk <- c(5:8) # Significance without Geometries (time cost)
Feat.Inter.blk <- c(5:6,21:30) # Interpretation without Geometries (time cost)
Feat.ALL <- c(1:73) # All features
## field selection
lrows <- list(#list("v3","_Archaeological_Finds",c(184:210))#, c(184:210)
list("v4","entites.v4","_Features",Feat.Assmt) # c(1:73) c(5,71:73)
# list("ucop","obj.UCOP","_Archaeological_Finds",c(1:27))
# list("ddn","obj.DDN","_Archaeological_Finds",c(1:27))
#list("_Photos",c(117))
)
for (rws in lrows){
# loop through the n:m rows in the bulk correspondances (ie output columns)
# rws <- lrows[[1]]
bulk.from.version <- rws[[1]] # numero of the fieldsheet version (v3, v4, etc.)
corresp.ws <- rws[[2]] # name of the worksheet to read in the corresponding excel
nme.bulk <- rws[[3]] # name of the out bulk
fields.bulk <- rws[[4]] # name of the rows of the bulk
print(paste0("BULK: ",corresp.ws," ",bulk.from.version,nme.bulk))
struct.bulk <- f.corresp.bulk(corresp.ws) # reload corresponding table
# filter on entities (Features, Archaeological_Finds, etc.)
str.bulk.select <- struct.bulk[struct.bulk$rcu_entite == nme.bulk,]
### Data & Layouts
## Features
if (nme.bulk == "_Features"){
dt.all <- f.layout(reload.bd,vZ)
dt.all <- dt.all[!(dt.all$Feat.Inte.Type == "Door"),] # rm Doors for the bulk
f.feat.geom() # get features geom, useful ?
# dt.all <- oss.all.vZ
}
## Objects
# DDN
if (nme.bulk == "_Archaeological_Finds" & corresp.ws == "obj.DDN"){
xlsx.fs <- paste0(chm_objets_ddn,file.objects.ddn)
dt.all <- o.layout(xlsx.fs)
# objects.idiha.ddn <- o.layout()
}
reinit_bulk(nme.bulk,bulk.from.version) # create empty bulk + COMM sheet
# if(nme.bulk == '_Features'){f.feat.geom()} # get features geom
nme.bulk.out <- paste0(nme.bulk,"_out.xlsx")
out.blk <- paste0(chm_BD,bulk_dir,"_",bulk.from.version,nme.bulk.out)
# create a commentary correspondances first sheet in the bulk
#f.commt.bulk(out.blk,nme.bulk,bulk.from.version)
for (r in fields.bulk){
# loop through rows selecting on subset df by num
# r <- 8
field_num <- str.bulk.select[str.bulk.select$num == r,"num"]
rcu_entite <- str.bulk.select[str.bulk.select$num == r,"rcu_entite"]
rcu_onglet <- str.bulk.select[str.bulk.select$num == r,"rcu_onglet"]
rcu_field_name <- str.bulk.select[str.bulk.select$num == r,"rcu_field_name"]
rcu_field_num <- str.bulk.select[str.bulk.select$num == r,"rcu_field_num"]
ucop_field_name <- str.bulk.select[str.bulk.select$num == r,"ucop_field_name"]
ucop_pattern <- str.bulk.select[str.bulk.select$num == r,"ucop_pattern"]
ucop_spec_funct <- str.bulk.select[str.bulk.select$num == r,"spec_funct"]
# messages
#print(cat(paste0(rep(espace,1)),rcu_entite))
print(cat(paste0(rep(espace,1)),corresp.ws))
print(cat(paste0(rep(espace,2)),field_num))
print(cat(paste0(rep(espace,3)),rcu_onglet))
print(cat(paste0(rep(espace,5)),rcu_field_name))
print(cat(paste0(rep(espace,5)),rcu_field_num))
print(cat(paste0(rep(espace,7)),ucop_spec_funct)) # special function
### apply the hub function - - - - - - - - - - - -
### UCOP
## Features
if(nme.bulk == '_Features'){
#dt.all <- head(oss.all.vZ,5)
#
# df.version <- paste0("oss.all.",bulk.from.version)
# exp.read.df.version <- paste0("dt.all <- ",df.version)
# eval(parse(text=exp.read.df.version)) # create 'dt.all'
CopyInfos(corresp.ws,out.blk,dt.all,
rcu_entite,rcu_onglet,rcu_field_name,rcu_field_num,
ucop_field_name,ucop_pattern,ucop_spec_funct)
}
## UCOP Archaeological Finds
if(nme.bulk == '_Archaeological_Finds' & corresp.ws == 'obj.UCOP'){
# for UCOP survey
dt.all <- f.ucop_archaeological_finds()  # appropriate format
CopyInfos(corresp.ws,out.blk,dt.all,
rcu_entite,rcu_onglet,rcu_field_name,rcu_field_num,
ucop_field_name,ucop_pattern,ucop_spec_funct)
print(cat("DONE ",paste0(rep(espace,20))))
}
### DDN
## DDN Archaeological Finds
if(nme.bulk == '_Archaeological_Finds' & corresp.ws == 'obj.DDN'){
# for DDN survey
# dt.all <- objects.idiha.ddn
CopyInfos(corresp.ws,out.blk,dt.all,
rcu_entite,rcu_onglet,rcu_field_name,rcu_field_num,
ucop_field_name,ucop_pattern,ucop_spec_funct)
print(cat("DONE ",paste0(rep(espace,20))))
}
}
# add a pattern in the sheet "zzAssessment" or "zzzAssessment"
if(nme.bulk == '_Features'){aMotifSupp(out.blk,"zzAssessment")}
if(nme.bulk == '_Archaeological_Finds'){aMotifSupp(out.blk,"zzzAssessment")}
#if(nme.bulk %in% c('_Features','_Archaeological_Finds')){aMotifSupp(out.blk,"zzAssessment")}
}
shell.exec(out.blk)
structure_server <- paste0(chm,"SERVER")
path <- list.files(structure_server,
recursive = T,
full.names = F)
x <- lapply(strsplit(path, "/"), function(z) as.data.frame(t(z)))
x <- plyr::rbind.fill(x)
x$pathString <- apply(x, 1, function(x) paste(trimws(na.omit(x)), collapse="/"))
(mytree <- data.tree::as.Node(x))
mytree
mytree
# create a view of the excel sheet with completed & missing data
# show also names of fields used to fill IDIHA DB
# chm_corresp_bulk <- paste0(chm_BD,bulk_dir,bulk.corresp.feuil) # fichier des correspondances
# struct.bulk <- read.xlsx(chm_corresp_bulk,
#                          sheet="entites", # onglet
#                          rowNames = F,
#                          colNames = T,
#                          skipEmptyRows=TRUE)
ucop_field_name <- as.character(na.omit(struct.bulk$ucop_field_name)) # ucop filed names
ucop_field_name <- unlist(strsplit(ucop_field_name,','))
# field to add to IDIHA transfert
add.fields <- c("Feat.Coords","Arch.Part.Top","Arch.Part.Roof",
"Arch.Part.iFloor","Arch.Part.Wall","Arch.Part.Subst",
"Arch.Part.Found","Mort.Type","Plast.Type")
ucop_field_name <- c(ucop_field_name,add.fields)
col.pos <- match(colnames(oss.all.vZ),ucop_field_name) # index of columns
col.pos <- which(!is.na(col.pos))
col.index <- data.frame(lbl=colnames(oss.all.vZ)[col.pos],
# id=1:length(col.pos),
xmin=col.pos-0.5,xmax=col.pos+0.5,
ymin=0,ymax=Inf) # to df for ggplot
# field to suppress to IDIHA transfert
supp.fields <- c("Feat.Version","Feat.Checked","Feat.Observat","AU","AV","AW",
"Note.version","Note.verif","Note.observ")
oss.all.vZ.studied <- oss.all.vZ[, ! names(oss.all.vZ) %in% supp.fields, drop = F]
#oss.all.vZ.studied <- subset(oss.all.vZ, select = -c("AW"))
gg <- oss.all.vZ.studied %>%
is.na %>%
melt %>%
ggplot(data = .,
aes(x = Var2,
y = Var1)) +
geom_raster(aes(fill = value)) +
geom_rect(data=col.index, inherit.aes=FALSE,
aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax,
group=lbl), fill = "yellow", alpha=0.7)+
geom_text(data=col.index, inherit.aes=FALSE,
aes(x = xmin,y=nrow(oss.all.vZ),label=lbl),angle=90,size=2.5,vjust=1,hjust=1)+
scale_fill_grey(name = "",
labels = c("recorded","n/a"))+
labs(x = "descriptive fields",
y = "features")+
theme(legend.position="top",
legend.text=element_text(size=12),
axis.title=element_text(size=12,face="bold"),
axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.text.y = element_text(angle = 90, hjust = 1, size=12),
panel.background = element_blank())
ggsave(paste0(chm_BD,"(verif)/NA_data.pdf"),gg,width = 27, height = 19, units = "cm")
struct.bulk
struct.bulk
head(oss.all.vZ)
system.file("extdata", "imgs.csv", package = "decorr")
?read.table
default.stringsAsFactors()
setwd("D:/Projet Art Rupestre/scripts/scripts_r/package_create/iconr/inst/extdata")
imgs.df <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
sep="\t", stringsAsFactors = FALSE)
lbl.size <- 25
lims <- list()
for(i in 1:4){
i1 <- magick::image_read(imgs.df[i,"img"])
lbl.txt <- paste0(imgs.df[i,"idf"],"\n",
imgs.df[i,"site"],"\n",
imgs.df[i,"decor"],"\n",
imgs.df[i,"img"],"\n",
image_info(i1)$width,"*",image_info(i1)$height," px")
i1 <- magick::image_annotate(i1,lbl.txt,location = "northwest",size = lbl.size, color = "red")
lims[[length(lims)+1]]<- i1
)
setwd("D:/Projet Art Rupestre/scripts/scripts_r/package_create/iconr/inst/extdata")
imgs.df <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
sep="\t", stringsAsFactors = FALSE)
lbl.size <- 25
lims <- list()
for(i in 1:4){
i1 <- magick::image_read(imgs.df[i,"img"])
lbl.txt <- paste0(imgs.df[i,"idf"],"\n",
imgs.df[i,"site"],"\n",
imgs.df[i,"decor"],"\n",
imgs.df[i,"img"],"\n",
image_info(i1)$width,"*",image_info(i1)$height," px")
i1 <- magick::image_annotate(i1,lbl.txt,location = "northwest",size = lbl.size, color = "red")
lims[[length(lims)+1]]<- i1
}
setwd("D:/Projet Art Rupestre/scripts/scripts_r/package_create/iconr/jss-article-rnw/imgs")
# plot side-by-side
out.img <- magick::image_append(c(image_append(c(lims[[1]],lims[[2]])),
image_append(c(lims[[3]],lims[[4]]))),
stack = TRUE)
magick::image_write(out.img, path = "corpus.png", format = "png")
library(magick)
setwd("D:/Projet Art Rupestre/scripts/scripts_r/package_create/iconr/inst/extdata")
imgs.df <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
sep="\t", stringsAsFactors = FALSE)
lbl.size <- 25
lims <- list()
for(i in 1:4){
i1 <- magick::image_read(imgs.df[i,"img"])
lbl.txt <- paste0(imgs.df[i,"idf"],"\n",
imgs.df[i,"site"],"\n",
imgs.df[i,"decor"],"\n",
imgs.df[i,"img"],"\n",
image_info(i1)$width,"*",image_info(i1)$height," px")
i1 <- magick::image_annotate(i1,lbl.txt,location = "northwest",size = lbl.size, color = "red")
lims[[length(lims)+1]]<- i1
}
setwd("D:/Projet Art Rupestre/scripts/scripts_r/package_create/iconr/jss-article-rnw/imgs")
# plot side-by-side
out.img <- magick::image_append(c(image_append(c(lims[[1]],lims[[2]])),
image_append(c(lims[[3]],lims[[4]]))),
stack = TRUE)
magick::image_write(out.img, path = "corpus.png", format = "png")
library(decorr)
plot(hist(norm(20)))
norm(20)
print(system.file("extdata", "imgs.tsv", package = "decorr"))
print(system.file("extdata", package = "decorr"))
?image_info
imgs
nodes
nodes <- read.table(system.file("extdata", "nodes.csv", package = "decorr"),
sep="\t",stringsAsFactors = FALSE)
nodes
nodes
subset(nodes, decor == "Cerro Muriano 1")
nodes <- read.table(system.file("extdata", "nodes.csv", package = "decorr"),
sep="\t",stringsAsFactors = FALSE)
nodes
subset(nodes, decor == "Cerro Muriano 1" & a == 8)
subset(nodes, decor == "Cerro Muriano 1" & id == 8)
subset(nodes, decor == "Cerro Muriano 1" & id == 8)[,c("x","y"]
subset(nodes, decor == "Cerro Muriano 1" & id == 8)[,c("x","y")]
cm.1 <- subset(nodes, decor == "Cerro Muriano 1" & id == 1)[,c("x","y")]
cm.8 <- subset(nodes, decor == "Cerro Muriano 1" & id == 8)[,c("x","y")]
cm.1
as.character(cm.1)
as.numeric(cm.1)
paste0(as.numeric(cm.1),";",as.numeric(cm.1))
as.numeric(cm.1)
cat(as.numeric(cm.1),as.numeric(cm.8))
cat(as.numeric(cm.1),as.numeric(cm.8),sep = ",")
paste0(as.numeric(cm.1),";",as.numeric(cm.1))
cat(as.numeric(cm.1),";",as.numeric(cm.8))
sit <- "Torrejon Rubio" ; dec <- "Torrejon Rubio 1"
nds.df <- read_nds(site = sit, decor = dec, dev = ".tsv",
doss = system.file("extdata", package = "decorr"))
eds.df <- read_eds(site = sit, decor = dec, dev = ".tsv",
doss = system.file("extdata", package = "decorr"))
eds.df
nds.df
?read.table
eds.df
eds.df[1,paste0("xa","xb")]
eds.df[1,"xa"]
?plot_dec_grph
plot(image_read(eds_compar))
imgs <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
sep="\t", stringsAsFactors = FALSE)
nodes <- read.table(system.file("extdata", "nodes.csv", package = "decorr"),
sep="\t",stringsAsFactors = FALSE)
edges <- read.table(system.file("extdata", "edges.csv", package = "decorr"),
sep="\t",stringsAsFactors = FALSE)
lgrph <- list_dec(imgs,nodes,edges,var="type")
g.compar <- list_eds_compar(lgrph,"type")
eds_compar <- plot_eds_compar(g.compar, c(1,4),
doss = system.file("extdata", package = "decorr"))
plot(image_read(eds_compar))
plot(image_read(eds_compar))
image_write(image_read(eds_compar),"D:\essai.png")
image_write(image_read(eds_compar),"D:/essai.png")
getwd()
df.same_edges
df.same_edges <- same_eds(lgrph,"type")
df.same_edges
class(df.same_edges)
library("MASS");library(decorr):library(xtable)
?xtable
df.same_edges
df.same_nodes
df.same_nodes<- same_nds(lgrph,"type")
df.same_nodes
hclust(df.same_nodes)
?dist(align)
df.same_nodes
m = matrix(rnorm(25), 250, 5)
m
dist(df.same_nodes)
df.same_nodes
inv(df.same_nodes)
install.packages("matlib")
(AI  <- inv(df.same_nodes))
library(matlib)
(AI  <- inv(df.same_nodes))
(AI  <- inv(as.matrix(adf.same_nodes)))
(AI  <- inv(as.matrix(df.same_nodes)))
df.same_nodes
dist(AI)
hclust(dist(AI))
plot(hclust(dist(AI)))
df.same_edges
df.same_nodes
plot_nds_compar <- function(listg, graph2, doss=getwd(), var="type"){
flistg <- unlist(listg, recursive = FALSE) # flatten list
lidf <- unique(unlist(lapply(flistg, function(x) x$name)))
ldec.comp <- t(utils::combn(lidf, 2)) # all pairwise comparisons
A <- graph2[1] ; B <- graph2[2] # ; nb.comm.eds <-
ridx <- which(ldec.comp[,1] == A & ldec.comp[,2] == B, arr.ind = T)
g <- listg[[ridx]] # a row = two graphs
out.compar <- paste0("compar_nds_",as.character(A),"_",as.character(B),".png")
tit <- paste0("nodes: compare decorations '",A,"' and '",B,"'")
grDevices::png(out.compar, width = 14, height=7, units = "cm", res=300)
graphics::par(mfrow=c(1,2),
mar=c(0,0,0,0))    # set the plotting area into a 1*2 array
side_plot_nds(g, 1, doss, var); side_plot_nds(g, 2, doss, var) # call to plot
graphics::mtext(tit, side = 1, line = -1, outer = TRUE, cex=0.8)
grDevices::dev.off()
return(paste0(getwd(),"/",out.compar))
}
nds_compar.2.4 <- plot_nds_compar(g.compar, c(2,4),
doss = system.file("extdata", package = "decorr"))
plot_nds_compar <- function(listg, graph2, doss=getwd(), var="type"){
flistg <- unlist(listg, recursive = FALSE) # flatten list
lidf <- unique(unlist(lapply(flistg, function(x) x$name)))
ldec.comp <- t(utils::combn(lidf, 2)) # all pairwise comparisons
A <- graph2[1] ; B <- graph2[2] # ; nb.comm.eds <-
ridx <- which(ldec.comp[,1] == A & ldec.comp[,2] == B, arr.ind = T)
g <- listg[[ridx]] # a row = two graphs
out.compar <- paste0("compar_nds_",as.character(A),"_",as.character(B),".png")
tit <- paste0("nodes: compare decorations '",A,"' and '",B,"'")
grDevices::png(out.compar, width = 14, height=7, units = "cm", res=300)
graphics::par(mfrow=c(1,2),
mar=c(0,0,0,0))    # set the plotting area into a 1*2 array
side_plot_nds(g, 1, doss, var); side_plot_nds(g, 2, doss, var) # call to plot
graphics::mtext(tit, side = 1, line = -1, outer = TRUE, cex=0.8)
grDevices::dev.off()
return(paste0(getwd(),"/",out.compar))
}
g.compar <- list_nds_compar(lgrph,"type")
nds_compar.2.4 <- plot_nds_compar(g.compar, c(2,4),
doss = system.file("extdata", package = "decorr"))
plot(image_read(nds_compar.2.4))
plot_nds_compar <- function(listg, graph2, doss=getwd(), var="type"){
flistg <- unlist(listg, recursive = FALSE) # flatten list
lidf <- unique(unlist(lapply(flistg, function(x) x$name)))
ldec.comp <- t(utils::combn(lidf, 2)) # all pairwise comparisons
A <- graph2[1] ; B <- graph2[2] # ; nb.comm.eds <-
print (A)
ridx <- which(ldec.comp[,1] == A & ldec.comp[,2] == B, arr.ind = T)
g <- listg[[ridx]] # a row = two graphs
out.compar <- paste0("compar_nds_",as.character(A),"_",as.character(B),".png")
tit <- paste0("nodes: compare decorations '",A,"' and '",B,"'")
grDevices::png(out.compar, width = 14, height=7, units = "cm", res=300)
graphics::par(mfrow=c(1,2),
mar=c(0,0,0,0))    # set the plotting area into a 1*2 array
side_plot_nds(g, 1, doss, var); side_plot_nds(g, 2, doss, var) # call to plot
graphics::mtext(tit, side = 1, line = -1, outer = TRUE, cex=0.8)
grDevices::dev.off()
return(paste0(getwd(),"/",out.compar))
}
g.compar <- list_nds_compar(lgrph,"type")
nds_compar.2.4 <- plot_nds_compar(g.compar, c(2,4),
doss = system.file("extdata", package = "decorr"))
plot(image_read(nds_compar.2.4))
# listg <- g.compar; graph2 <- c(2,4) ; doss = system.file("extdata", package = "decorr")
flistg <- unlist(listg, recursive = FALSE) # flatten list
lidf <- unique(unlist(lapply(flistg, function(x) x$name)))
ldec.comp <- t(utils::combn(lidf, 2)) # all pairwise comparisons
A <- graph2[1] ; B <- graph2[2] # ; nb.comm.eds <-
listg <- g.compar; graph2 <- c(2,4) ; doss = system.file("extdata", package = "decorr")
flistg <- unlist(listg, recursive = FALSE) # flatten list
lidf <- unique(unlist(lapply(flistg, function(x) x$name)))
ldec.comp <- t(utils::combn(lidf, 2)) # all pairwise comparisons
A <- graph2[1] ; B <- graph2[2] # ; nb.comm.eds <-
A
B
lidf <- unique(unlist(lapply(flistg, function(x) x$name)))
ldec.comp <- t(utils::combn(lidf, 2)) # all pairwise comparisons
A <- graph2[1] ; B <- graph2[2] # ; nb.comm.eds <-
print (A)
ridx <- which(ldec.comp[,1] == A & ldec.comp[,2] == B, arr.ind = T)
ridx
g
g <- listg[[ridx]] # a row = two graphs
g
V(g[[1]])
igraph::V(g[[1]])
as.character(igraph::V(g[[1]]))
igraph::V(g[[1]])$name
intersect(igraph::V(g[[1]])$name,igraph::V(g[[2]])$name)
length(intersect(igraph::V(g[[1]])$name, igraph::V(g[[2]])$name))
plot_nds_compar <- function(listg, graph2, doss=getwd(), var="type"){
# listg <- g.compar; graph2 <- c(2,4) ; doss = system.file("extdata", package = "decorr")
flistg <- unlist(listg, recursive = FALSE) # flatten list
lidf <- unique(unlist(lapply(flistg, function(x) x$name)))
ldec.comp <- t(utils::combn(lidf, 2)) # all pairwise comparisons
A <- graph2[1] ; B <- graph2[2] # ; nb.comm.eds <-
print (A)
ridx <- which(ldec.comp[,1] == A & ldec.comp[,2] == B, arr.ind = T)
g <- listg[[ridx]] # a row = two graphs
nb.comm <- length(intersect(igraph::V(g[[1]])$name, igraph::V(g[[2]])$name))
out.compar <- paste0("compar_nds_",as.character(A),"_",as.character(B),".png")
tit <- paste0("Decorations '",A,"' and '",B,"', ",nb.comm," common nodes")
grDevices::png(out.compar, width = 14, height=7, units = "cm", res=300)
graphics::par(mfrow=c(1,2),
mar=c(0,0,0,0))    # set the plotting area into a 1*2 array
side_plot_nds(g, 1, doss, var); side_plot_nds(g, 2, doss, var) # call to plot
graphics::mtext(tit, side = 1, line = -1, outer = TRUE, cex=0.8)
grDevices::dev.off()
return(paste0(getwd(),"/",out.compar))
}
g.compar <- list_nds_compar(lgrph,"type")
nds_compar.2.4 <- plot_nds_compar(g.compar, c(2,4),
doss = system.file("extdata", package = "decorr"))
plot(image_read(nds_compar.2.4))
g.compar <- list_eds_compar(lgrph,"type")
listg <- g.compar; graph2 <- c(2,4) ; doss = system.file("extdata", package = "decorr")
flistg <- unlist(listg, recursive = FALSE) # flatten list
lidf <- unique(unlist(lapply(flistg, function(x) x$name)))
ldec.comp <- t(utils::combn(lidf, 2)) # all pairwise comparisons
A <- graph2[1] ; B <- graph2[2] # ; nb.comm.eds <-
ridx <- which(ldec.comp[,1] == A & ldec.comp[,2] == B, arr.ind = T)
g <- listg[[ridx]]
igraph::E(g[[1]])$name
igraph::E(g[[1]])
igraph::E(g[[1]])$names
igraph::E(g[[1]])$nme
as.character(igraph::E(g[[1]]))
as_data_frame(g, what="edges")
igraph::as_data_frame(g, what="edges")
igraph::as_data_frame(g[[1]], what="edges")
E(g[[1]])
igraph::E(g[[1]])
edgesA <- igraph::as_data_frame(g[[1]], what="edges")
