\documentclass[article]{jss}

%% -- LaTeX packages and custom commands ---------------------------------------

%% recommended packages
\usepackage{thumbpdf,lmodern}
\usepackage{float,tikz}
%% another package (only for this demo article)
\usepackage{framed} 
%% author pakckage
\usepackage{xcolor,caption, float}

\graphicspath{ {./imgs/} }

%% new custom commands
\newcommand{\class}[1]{`\code{#1}'}
\newcommand{\fct}[1]{\code{#1()}}

% <<preliminaries, echo=FALSE, results=hide>>=
<<preliminaries, echo=FALSE>>=
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
library("MASS")
@

%% -- Article metainformation (author, title, ...) -----------------------------

%% - \author{} with primary affiliation
%% - \Plainauthor{} without affiliations
%% - Separate authors by \And or \AND (in \author) or by comma (in \Plainauthor).
%% - \AND starts a new line, \And does not.
\author{Thomas Huet\\UMR 5140}
%   \And Second Author\\Plus Affiliation}
\Plainauthor{Thomas Huet}

%% - \title{} in title case
%% - \Plaintitle{} without LaTeX markup (if any)
%% - \Shorttitle{} with LaTeX markup (if any), used as running title
\title{Modelling Prehistorical Iconographic Compositions. The \proglang{R} package \pkg{decorr}}
\Plaintitle{Modelling Prehistorical Iconographic Compositions. The R package 'decorr'}
\Shorttitle{Modelling Prehistorical Iconographic Compositions}

%% - \Abstract{} almost as usual
\Abstract{
  By definition, Prehistorical societies are characterised by the absence of a writing system. Prehistorical times cover more than 99\% of the human living. Even if it is being discussed, first symbolic manifestations start around 200,000 BC \citep{dErrico00}. The duration from first symbolic expressions to start of writing represents 97\% of the human living. In illiterate societies, testimonies of symbolic systems mostly come from iconography (ceramic decorations, rock-art, statuary, etc.) and signs are displayed mostlty a discontinuous figures which can have different relationships one with another. An graphical composition can be "read" as a spatial distribution of features having intrinsic values possibily having meaningful relationships one with another depending on their pairwise spatial proximities. 

  To understand meaningful associations of signs, geometric tools, graph analysis and statistical analysis offer great tools to recognize iconographical patterns and to infer collective conventions. We present the \pkg{decorr} \proglang{R} package which ground concepts, methods and tools to analyse ancient graphical systems.
}

\Keywords{Iconography, Prehistory, Graph Theory, Graph Drawing, Spatial Analysis, \proglang{R}}
\Plainkeywords{Iconography, Prehistory, Graph Theory, Graph Drawing, Spatial Analysis, R}

\Address{
  Thomas Huet\\
  CNRS-UMR 5140 \\
  Archeologie des Societes Mediterraneennes\\
  Universite Paul Valery\\
  route de Mende\\
  Montpellier 34199, France\\
  E-mail: \email{thomashuet7@gmail.com}\\
%  URL: \url{https://eeecon.uibk.ac.at/~zeileis/}
}

\begin{document}
\SweaveOpts{concordance=TRUE}

\section[Introduction]{Introduction} \label{sec:intro}

For decades, study of ancient iconography was linked to history of religion because closely linked to symbolism, believes and religions. Since the \textit{New Archaeology} developpement during the 60's \citep{Clarke14}, symbolic expressions start to be studied with the same formal methods (statistics, seriations, distribution maps, etc.) as any another aspect of social organisation: settlement patterns, tools \emph{chaine op√©ratoire}, susbsitence strategies, etc. \citep{Renfrew91}, \citep{LeroiGourhan92}. But unlike many aspects of the material culture -- a flint blade for cutting, a pottery for containing, a house for living --, the function of an iconographic composition cannot be drawn directly from itself. Whether study of ancient iconography had  undergone significative improvements at the site scale -- with GIS, database, paleoclimatic restitutions, etc. -- and at the sign scale with the development of archaeological sciences -- radiocarbon dating, use-wear analysis, elemental analysis, etc. --, these improvement do not necessarly help to understand the semantic content of the iconography.
Semantics or semiotics can be defined as a system of conventional signs organised also in conventional manners.  
Until our days, formal methods to study ancient iconography Semantics, has been mostlty been grounded (explicitly or not) on the prime principle of Saussurian linguistic: the 'linearity of the signifier' \citep{Saussure89}. Writing is one of the most rational semiographical system with a clear distinction between signified and signifier -- specially in alphabetic and binary writings -- and the development of the signified on a horizontal, vertical or boustrophedon axis. 
Let us take the example of the word "\code{art}" which contains three vertices (\code{a}, \code{r}, \code{t}) and two edges (one between \code{a} and \code{r}, the other between \code{r} and \code{t}). In \proglang{R}, these features, concatenated in this order with a \code{paste0()}, is \code{art}, and not \code{rat}, 

\SweaveOpts{width=5,height=3}
\begin{figure}[H]
<<echo=FALSE, fig=TRUE, height=3>>=
library(igraph);library(extrafont)
par(mar=c(0.1,0.1,0.1,0.1) )
# loadfonts(device = "win")
# ugs <- data.frame(name=c("a","r","t"))
# lks <- data.frame(from=c("a", "r"),to=c("r", "t"),type=c("=","="))
# g <- graph_from_data_frame(lks, directed=FALSE, vertices= ugs)
g <- graph_from_literal(a-+r, r-+t)
# lo <- cbind(seq(-1,1,length.out = gorder(g)), 0)
plot(g,
     layout = cbind(seq(-1,1,length.out = gorder(g)), 0),
     vertex.color="white",
     vertex.frame.color="white",
     vertex.size=60,
     vertex.label.cex=1.5,
     vertex.label.color="black",
     vertex.label.family="Courier New",
     edge.arrow.size=.5)
@
\captionof{figure}[directional links]{concatenate of \code{a}, \code{r} and \code{t} graphical units (GUs) is \code{art}.}
\end{figure}
But, as stated, in Prehistorical the writing system does not exists. Spatial relationships between graphical features, or graphical units (GUs) are not necessarly linear and directed but could most probably be more multi-directional and undirected: the direction of the interactions of pairwise GUs can be in any order.  

\begin{figure}[H]
<<echo=FALSE, fig=TRUE, height=3>>=
# library(extrafont)
# loadfonts(device = "win")
par(mar=c(0.1,0.1,0.1,0.1) )
ugs <- data.frame(name=c("a","r","t"))
lks <- data.frame(from=c("a", "r", "t"),to=c("r", "t", "a"),type=c("=","=","="))
g <- igraph::graph_from_data_frame(lks, directed=FALSE, vertices= ugs)
plot(g,
     vertex.color="white",
     vertex.frame.color="white",
     vertex.size=80,
     vertex.label.cex=1.5,
     vertex.label.color="black",
     vertex.label.family="Courier New"
     )
@
\captionof{figure}[multidirectional links]{Potential spatial relations between \code{a}, \code{r} and \code{t} GUs.}
\end{figure}

Applying the Saussurian model to any prehistorical graphical content had led to tedious division of the iconographical content with, for example, graphical as a relationship of \emp{figures} grouping GUs, \emp{patterns} grouping \emp{figures}, \emp{motives} grouping \emp{patterns}, etc., until the entire decorated support is described and can be compared to another decoration (XXX). But during this \emph{decomposition} process, many imprecisions occur:
\begin{itemize}
  \item groups and relationships are often defined empirically
  \item their level of significance are often implicit 
  \item the iconographical and spatial proximities between GUs and categories of GUs are not quantified
\end{itemize}

Furthermore, due to the inherent variability of iconography, most of the studies developp proper descriptive vocabularies, singular relationships of categories, idosyncratic methods in a site-dependend or period-dependend scales. This limits drastically the possibility to conduct cross-cultural comparisons and to draw a synthesis of humankind's symbolism at a large scale and over the long-term. 
\\
\\
In this article we present the \proglang{R} package \pkg{decorr}. Its purpose is to formalise a method based on geometric graphs to analyse any graphical content. As any formal system, iconography can be modelled as spatial features related one with the other depending on rules of spatial proximities. The idea is that a graphical system can be represented by vertices connected (or not) to each other with edges. This package has been grounded on the seminal work of C. Alexander \citep{Alexander08} and its first IT implementation by T. Huet \citep{Huet18a}. 

\section[Model]{Model} \label{sec:model}

Graph theory offers a conceptual framework and indices (global at the entire graph scale, local at the vertex scale) to deal with notions of networks, relationships and neighbourhoods. The spatial levels of the GUs can be retrieve by a planar graph (Graph Theory) and a spatial (GIS) analysis.
Nodes and edges -- repectively for GUs and their connexion -- are created on a GIS interface. 
In the GIS, the decoration figure is open in the first place in a new project with no projection. The decoration image will be considerated as the basemap of the project and will cover the region of interest of the analysis. The decoration image can be binarized where GUs are considerated active and the undecorated parts of the support, or background, are considerated inactive. After what, the decoration image is tiled. A simplier solution will be to create directly centroids over the GUs. The \emph{x} and \emph{y} coordinates of the nodes are relative to the decoration and measured in pixels.
Exist a link between a couple of GUs when these graphical units share a border. A planar graph is constructed from grahical units (nodes) and their proximity links (edges). This model is a Voronoi diagram of the support where the Voronoi seeds are the GUs. Its geographical equivalent is a Thiessen polygon.


\begin{figure}[H]
\centering
\includegraphics{gis}
\caption{\label{fig:gis} GIS interface. A) Original decoration of the Late Bronze Age \emp{Cerro Muriano 1} stele (drawing: \cite{DiazGuardamino10}) with its extent (\code{xmin, xmax, ymin, ymax}); B) After the polygonisation of the GUs, including the border of the stelae, the Voronoi cells, the centroid of GUs and the links between GUs having adjacent cells (ie, sharing a border) are calculated; C) For each GUs, \emph{x} and \emph{y} are calculated; D) At least one variable, like the \code{type} of the GUs is defined in order to compute composition analysis.}
\end{figure}

This model has a minimal of \emph{a priori} definitions. Those definitions only concern the GUs (type, technology, color, orientation, size, etc.). The plasticity of fraph theory allows to develop conventions in order to quote the different types of relations between GUs.\\

By convention, two different GUs having a Voronoi cell sharing a border, have an edge tagged \code{'='} and represented with a plain line. The textual notation of a such edge is \code{'-=-'}. For example: \code{1 -=- 4} means that the nodes \code{1} and \code{4} have a common border.

But it occurs frequently that a GU can be divided into a \emph{main unit} (eg, a character) and one or various \emph{attribute units} (eg, a helmet, male sex). To record this information, a new type of edge, tagged with \code{'+'}, is be introduced. This type of edges is be directed and displayed with a dashed line. Its starts from the \emph{main unit} and ends with the \emph{attribute units}. For example \code{4 -+- 6}) means that the main node \code{4} has the attribute node \code{6}.

\begin{figure}[H] 
\centering
\includegraphics[scale=0.3]{gis_1}
\caption{\label{fig:gis1} GIS interface. The GUs 'casque' (helmet) and 'sexe\_masculin' (male sex) are two attributes of the GU 'personnage' (character).}
\end{figure}

Finally, it is quite common that a graphical composition shows superimpositions between different UGs. This stratigraphic information (\code{A} \emph{over} \code{B}, or \code{B} \emph{under} \code{A}) helps to understand the relative chronology between GUs and must be recorded. A simple way to achieve this is to introduce the new tag \code{'>'} for the for the type of edge. This type of edges is directed. For example \code{A ->- B} means that \code{A} crosses \code{B}. 


\begin{table}[H]
% \begin{center}
  \centering
 \begin{tabular}{|p{.5cm} p{.5cm} p{.5cm} p{2cm} p{2cm} p{5cm}|}
 \hline
  % node A & type of edge & node B & undirected & birel & stratigraphical meaning \\
 node 1 & edge type & node 2 & (un)directed & \emph{birel} & stratigraphical meaning \\
 \hline
  \code{A} & \code{=} & \code{B} & undirected & $ A \cap B = \emptyset $ & \code{A} and \code{B} are disjoint, \code{A} and \code{B} can be contemporaneous \\
  \code{A} & \code{+} & \code{B} & directed & $ A \cap B = A $ & \code{A} and \code{B} are contemporaneous, \code{B} is an attribute of \code{A} \\
  \code{A} & \code{>} & \code{B} & directed & $ A \cap B = \exists $ & \code{A} overlaps \code{B}, \code{A} can be more recent than \code{B} \\
 % \code{1} & = & 2 & undirected & A \cap B = \varnothing & 1 and 2 can be contemporaneous \\
 \hline
\end{tabular}
\caption{Synthesis for the different types of relations between GUs}\label{tab1}
% \end{center}
\end{table}

\section{The R package decorr} \label{sec:models}

The \pkg{decorr} package can be downloaded from GitHub
%
\begin{CodeChunk}
\begin{CodeInput}
R>   devtools::install_github("zoometh/iconr")
\end{CodeInput}
\end{CodeChunk}
%

\subsection{External package} \label{sec:ext_pck}

The \pkg{decorr} package imports the following packages:
\begin{itemize}
\setlength\itemsep{.1em}
  \item \pkg{magick} for image manipulation \citep{Ooms18}
  \item \pkg{igraph} for graph and network analysis \citep{Csardi06} 
  \item \pkg{rgdal}  to read shapefiles of nodes and/or edges \citep{Bivand19}
  \item \pkg{grDevices} for colors and font plotting, \pkg{graphics} for graphics, \pkg{utils} and \pkg{methods} for formally defined methods and \emph{varia} methods (all combinations, etc.) \citep{R19}
\end{itemize}

\subsection{Data} \label{sec:ext_data}

The training dataset is a selection of four drawing of stelae belonging to the Late Bronze age of the SW Iberian peninsula. At the first, the training dataset is in the \code{extdata} folder of the \pkg{decorr}. The dataframe storing the inventory of decorations is \code{imgs}.

\begin{itemize}
\item The \code{imgs} dataframe structure is
\end{itemize}

<<results='asis', echo=FALSE>>=
imgs <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
                   sep="\t", stringsAsFactors = FALSE)
print(xtable::xtable(imgs,
               caption="The studied corpus, the imgs.tsv dataframe",
               label="Test_table",
               size=6),
      include.rownames=FALSE)
@

The field \code{imgs$idf} is the short name of the decoration, useful during statistical analysis. The primary key of each decoration is the concatenate of \code{imgs$site} and \code{imgs$decor}.\\

At first the drawing dataset can be checked by using the \code{imgs} dataframe and the \pkg{magick}

\SweaveOpts{width=16,height=16}
\begin{figure}[H]
<<echo=TRUE, fig=TRUE, fig.height=5>>=
library(magick)
pth <- system.file("extdata", package = "decorr")
imgs <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
                      sep="\t", stringsAsFactors = FALSE)
lims <- list()
for(i in 1:nrow(imgs)){
  i1 <- image_read(paste0(pth,"\\",imgs[i,"img"]))
  lbl.txt <- paste0(imgs[i,"idf"],"\n",
                    imgs[i,"site"],"\n",
                    imgs[i,"decor"],"\n",
                    imgs[i,"img"],"\n",
                    image_info(i1)$width,"*",image_info(i1)$height," px")
  i1 <- image_annotate(i1,lbl.txt,location = "northwest",
                       size = 25, color = "red")
  lims[[length(lims)+1]]<- i1
}
out.img <- image_append(c(image_append(c(lims[[1]],lims[[2]])),
                          image_append(c(lims[[3]],lims[[4]]))),
                        stack = TRUE)
plot(out.img)
@
\captionof{figure}[directional links]{All decoration drawings belongs to \citep{DiazGuardamino10}}
\end{figure}

As said, the GIS offers the more suitable interface to register all GUs and to get their coordinates. But the coordinates origin (0,0) in a GIS is the bottom-left corner, while this origin is top-left for any \proglang{R} rasters or matrices: this will affect the \emph{y} axis. To recover the correct GUs coordinates on this axis, for nodes and edges, between the inputs in the GIS and the decoration image coordinates in \proglang{R}, the \pkg{decorr} calculate the absolute \emph{y} value and used the image height as a constant offset. 

To construct a graph overlapping the decoration images listed in the \code{images} dataframe, the first step is to load \code{nodes}, \code{edges} dataframes.

<<read_df, echo=TRUE>>=
nodes <- read.table(system.file("extdata", "nodes.csv", package = "decorr"),
                    sep="\t",stringsAsFactors = FALSE)
edges <- read.table(system.file("extdata", "edges.csv", package = "decorr"),
                    sep="\t",stringsAsFactors = FALSE)
@

\begin{itemize}
\item The \code{nodes} dataframe structure is
\end{itemize}

<<results='asis', echo=TRUE>>=
nodes.cm <- subset(nodes, decor == "Cerro Muriano 1")
caption <- "Nodes (\\code{nodes.csv} dataframe) for \\emph{Cerro Muriano 1}"
xtable::xtable(nodes.cm,
       caption = caption)
@

\begin{itemize}
\item The \code{edges} dataframe structure is
\end{itemize}

<<results='asis', echo=TRUE>>=
edges.cm <- subset(edges, decor == "Cerro Muriano 1")
caption <- "Edges (\\code{edges.csv} dataframe) for \\emph{Cerro Muriano 1}"
xtable::xtable(edges.cm,
               caption=caption)
@

For edges, there is no need to get the coordinates of the starting point and the ending point. These coordinates can be calculated from the \code{nodes} dataframe. For example, the first edge of the \emph{Cerro Muriano 1} decoration connect the nodes \code{1} and \code{8}. A way to retrieve coordinates of these two nodes -- which are the two end points -- will be:

<<echo=TRUE>>=
cm.1 <- subset(nodes, decor == "Cerro Muriano 1" & id == 1)[,c("x","y")]
cm.8 <- subset(nodes, decor == "Cerro Muriano 1" & id == 8)[,c("x","y")]
cat(as.numeric(cm.1),";",as.numeric(cm.8))
@

Once done, the list of graphs can be stored with the \code{list_dec()} function.

\subsection{\code{list\_dec()} function} \label{sec:funlistdec}

The \code{list\_dec()} function allows to store graphs for each decorations stored into \code{nodes}, \code{edges} and \code{images} dataframes and store the graphs in a list. The join between these dataframes is done on the two fields \code{site} and \code{decor}. The first graph of can be plotted

\begin{figure}[H]
% \SweaveOpts{width=2,height=2}
<<echo=TRUE, fig=TRUE, width=3, height=2>>=
par(mar=c(0.1,0.1,0.1,0.1) )
library(decorr)
# imgs <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
#                       sep="\t", stringsAsFactors = FALSE)
# nodes <- read.table(system.file("extdata", "nodes.csv", package = "decorr"),
#                     sep="\t",stringsAsFactors = FALSE)
# edges <- read.table(system.file("extdata", "edges.csv", package = "decorr"),
#                     sep="\t",stringsAsFactors = FALSE)
lgrph <- list_dec(imgs,nodes,edges,var="type")
plot(lgrph[[1]],
     vertex.color = "orange",
     vertex.frame.color="orange",
     vertex.label.color = "black",
     vertex.size = 10,
     vertex.label.cex =.7,
     edge.color = "orange"
     # vertex.label.family="Courier New"
     )
@
\captionof{figure}[directional links]{Plot of the first graph of the list}
\end{figure}

The others \pkg{decorr} package functions can be divided into:
\begin{enumerate}
 \item graphical functions
 \item single decoration functions
 \item comparisons between different decorations functions
\end{enumerate}

\subsection{Graphical functions} \label{sec:functions_gr}

The \pkg{decorr} has three purely graphical functions
\begin{itemize}
\setlength\itemsep{.1em}
\item \code{labels_shadow()} function is a re-use of the \code{shadowtext()} function from the \pkg{TeachingDemos} package \citep{Snow20}.
\item \code{side_plot_nds()} and \code{side_plot_eds()} allow to plot figures side-by-side for nodes or edges comparisons
\end{itemize}

\subsection{Single decoration functions} \label{sec:functions_one}

Functions allowing to create a geometric graph for a single decoration are:

\begin{itemize}
  \item \code{read_nds()} and \code{read_eds()} functions allow to read respectively a file of nodes and a file of edges (\code{.tsv} or \code{.shp} files)
\end{itemize}

The \code{read_nds()} function is close to the native \code{read.table()} function but allows to read \emph{shapefiles} of nodes.

the \code{read_eds()} permits to read a \emph{shapefiles} of nodes or to retrieve the coordinates of the ends of the edges from the \code{nodes} dataframe. For example, the first \emph{Torrejon Rubio 1} edge, between the nodes \code{6} and \code{5} has
the starting point (xa=366.7001, ya=-563.1358) and the ending point (xb=490.1195, yb=-513.2428)

\begin{figure}{H}
\centering
<<results='asis', echo=TRUE>>=
# library(decorr)
sit <- "Torrejon Rubio" ; dec <- "Torrejon Rubio 1"
nds.df <- read_nds(site = sit, decor = dec, dev = ".tsv",
                   doss = system.file("extdata", package = "decorr"))
eds.df <- read_eds(site = sit, decor = dec, dev = ".tsv",
                   doss = system.file("extdata", package = "decorr"))
xtable::xtable(eds.df[1,],
               caption="first edge of the dataframe",
               label="Test_table_1",
               size=7)
@
\end{figure}

\begin{itemize}
  \item \code{plot_dec_grph ()} allows to plot a geometric graph over a decoration image
\end{itemize}

Once, the imgs, nodes and edges dataframes have been read, the decoration graph is build and can be plotted, here for the \emph{Torrejon Rubio 1} decoration. The \code{lbl.txt} parameter allow to decide which field of the nodes will be displayed as the label, here the column \code{nodes$type}

\SweaveOpts{width=3,height=3}
\begin{figure}{H}
\centering
<<plotcm, echo=TRUE, fig=TRUE>>=
library(decorr)
par(mar=c(1,1,1,1) )
sit <- "Torrejon Rubio" ; dec <- "Torrejon Rubio 1"
nds.df <- read_nds(site = sit, decor = dec, dev = ".tsv",
                   doss = system.file("extdata", package = "decorr"))
eds.df <- read_eds(site = sit, decor = dec, dev = ".tsv",
                   doss = system.file("extdata", package = "decorr"))
img.graph <- plot_dec_grph(nds.df = nds.df,
                           eds.df = eds.df,
                           site = sit,
                           decor = dec,
                           doss = system.file("extdata", package = "decorr"),
                           lbl.txt = "type",
                           lbl.size=1.7,
                           shw = c("nodes","edges"))
plot(img.graph)
@
\captionof{figure}[directional links]{\emph{Torrejon Rubio 1}}
\end{figure}

\subsection{Decoration comparisons function} \label{sec:functions_one}

The functions allowing to compare different decorations with geometric graphs are

\begin{itemize}
  \item \code{list_nds_compar()} and \code{list_eds_compar()} functions allow to compare respectively the common nodes and the common edges between two decorations
\end{itemize}

Comparisons between pairwise of decorations are first stored into list. These comparisons are performed for nodes and/or edges. There are four (4) decorations in the default dataset, so there is $\frac{4!}{(4-2)!2!}={6}$ pairwise comparisons

<<results='asis', echo=FALSE>>=
# set wd to data folder
# setwd(system.file("extdata", package = "decorr"))
library(decorr)
g.compar <- list_eds_compar(lgrph,"type")
df.edges.compar <- data.frame(decorA=c(g.compar[[1]][[1]]$decor,
                                       g.compar[[2]][[1]]$decor,
                                       g.compar[[3]][[1]]$decor,
                                       g.compar[[4]][[1]]$decor,
                                       g.compar[[5]][[1]]$decor,
                                       g.compar[[6]][[1]]$decor),
                              decorB=c(g.compar[[1]][[2]]$decor,
                                       g.compar[[2]][[2]]$decor,
                                       g.compar[[3]][[2]]$decor,
                                       g.compar[[4]][[2]]$decor,
                                       g.compar[[5]][[2]]$decor,
                                       g.compar[[6]][[2]]$decor))
xtable::xtable(df.edges.compar,
               caption="comparison dataframe",
               label="Test_table_1",
               size=7)
@


\begin{itemize}  
  \item \code{plot_nds_compar()} and \code{plot_eds_compar()} functions allow to plot and save two figures side-by-side for a decorations pairwise with, respectively, common nodes and common edges identified
\end{itemize}

The \code{plot_nds_compar()}and \code{plot_eds_compar()} functions create a \code{.png} image of two decorations plotted side-by-side with common nodes or edges identified. Functions returns also the name of the image. The common edges or nodes are displayed in red by default. Let us choose the decorations \code{1} (\emph{Cerro Muriano 1}) and \code{4} (\emph{Zarza de Montsanchez})

\begin{figure}[H]
\SweaveOpts{width=20,height=10}
<<echo=TRUE, fig=TRUE>>=
par(mar=c(0,0,0,0))
eds_compar <- plot_eds_compar(g.compar, c(1,4),
                              doss = system.file("extdata", package = "decorr"))
plot(image_read(eds_compar))
@
\captionof{figure}[directional links]{comparisons between \code{1} (\emph{Cerro Muriano 1}) and \code{4} (\emph{Zarza de Montsanchez} decorations}
\label{edg_comp}
\end{figure}

The comparison on Figure \ref{edg_comp} shows that \code{1} (\emph{Cerro Muriano 1}) and \code{4} (\emph{Zarza de Montsanchez} decorations have two (2) common edges: \texttt{lance -=- personnage} and \texttt{bouclier -=- personnage}


\begin{itemize}
  \item \code{same_nds()} and \code{same_eds()} functions allow to repectively count matching nodes and matching edges between decoration pairwises
\end{itemize}

\code{same_nds()} and \code{same_eds()} allow to repectively count matching nodes and matching edges between decoration pairwises. The result is a square matrix with all pairwise comparisons and the number of common nodes or edges in the cells.

<<results='asis', echo=TRUE>>=
df.same_edges <- same_eds(lgrph,"type")
caption <- "Number of same edges between all decoration pairwise comparisons"
print(xtable::xtable(df.same_edges,
                     caption=caption,
                     label="Test_table_2",
                     size=8,
                     digits=c(0)),
      include.rownames=TRUE)
@

For these two last exemples, the edges comparisons between the decoration \code{1} and the decoration \code{4} show that they have two (2) common edges.


\section{Illustrations} \label{sec:illustrations}

In order to demonstrate the first insight of a graph-based analysis of the decorations, we will compare two classifications, one based on the presence of common nodes, the second based on the presence of common edges. As said, the first method (presence of common nodes) is the most commonly used method in statistical analysis on decorations since the exact location of the GUs is not commonly registred

\begin{table}[htb]
\begin{minipage}{.45\textwidth}
\centering
<<echo=FALSE,results='asis'>>=
library(xtable)
# library("MASS");library(decorr);library(xtable);library(magick)
# imgs <- read.table(system.file("extdata", "imgs.tsv", package = "decorr"),
#                    sep="\t",stringsAsFactors = FALSE)
# nodes <- read.table(system.file("extdata", "nodes.tsv", package = "decorr"),
#                     sep="\t",stringsAsFactors = FALSE)
# edges <- read.table(system.file("extdata", "edges.tsv", package = "decorr"),
#                     sep="\t",stringsAsFactors = FALSE)
# lgrph <- list_dec(imgs,nodes,edges,"type")
df.same_edges <- same_eds(lgrph,"type")
df.same_nodes<- same_nds(lgrph,"type")
# library("xtable")
print(xtable(df.same_nodes, digits=c(0)),
      floating=FALSE,
      hline.after=NULL)
@
\captionof{table}{Common nodes table}
\end{minipage}
\begin{minipage}{.45\textwidth}
\centering
<<echo=FALSE,results='asis'>>=
print(xtable(df.same_edges, digits=c(0)),
      floating=FALSE,
      hline.after=NULL)
@
\captionof{table}{Common edges table}
\end{minipage}
\end{table}

\begin{figure}[H]
<<echo=TRUE,fig=TRUE>>=
library(matlib)
par(mfrow=c(1,2))
dist.nodes  <- dist(inv(as.matrix(df.same_nodes)))
dist.edges  <- dist(inv(as.matrix(df.same_edges)))
plot(hclust(dist.nodes), hang = -1, main = "common nodes")
plot(hclust(dist.edges), hang = -1, main = "common edges")
@
\end{figure}

For both nodes and edges, the most distant decorations are \code{1} and \code{4}. These two decorations share four (4) common nodes and, as previously seen, two (2) common edges.
In any cases decorations \code{2} and \code{3} are closer to decoration \code{4} than to decoration \code{1}, but their classifications changes depending on counting of common nodes or common edges. Plotting the comparisons for for \code{3} and \code{4}, helps to understand the differences between the two classifications.

\begin{figure}[H]
\SweaveOpts{width=20,height=20}
<<echo=FALSE, fig=TRUE>>=
par(mar=c(0,0,0,0))
par(mfrow=c(2,1))
g.compar <- list_nds_compar(lgrph,"type")
nds_compar.3.4 <- plot_nds_compar(g.compar, c(3,4),
                                  doss = system.file("extdata", package = "decorr"))
plot(image_read(nds_compar.3.4))
g.compar <- list_eds_compar(lgrph,"type")
eds_compar.3.4 <- plot_eds_compar(g.compar, c(3,4),
                              doss = system.file("extdata", package = "decorr"))
plot(image_read(eds_compar.3.4))
@
\end{figure}


Decorations \code{3} and \code{4} share four (4) common GUs (\code{bouclier, epee, lance, miroir}) but the spatial organisation of theses GUs are different between the two decorations so their number of common edges is lower with only one common edge (\code{bouclier -=- lance})



%% -- Summary/conclusions/discussion -------------------------------------------

\section{Summary and discussion} \label{sec:summary}

\begin{leftbar}
As usual \dots
\end{leftbar}




%% -- Optional special unnumbered sections -------------------------------------

\section*{Computational details}

\begin{leftbar}
If necessary or useful, information about certain computational details
such as version numbers, operating systems, or compilers could be included
in an unnumbered section. Also, auxiliary packages (say, for visualizations,
maps, tables, \dots) that are not cited in the main text can be credited here.
\end{leftbar}

The results in this paper were obtained using
\proglang{R}~3.4.1 with the
\pkg{MASS}~7.3.47 package. \proglang{R} itself
and all packages used are available from the Comprehensive
\proglang{R} Archive Network (CRAN) at
\url{https://CRAN.R-project.org/}.


\section*{Acknowledgments}

\begin{leftbar}
All acknowledgments (note the AE spelling) should be collected in this
unnumbered section before the references. It may contain the usual information
about funding and feedback from colleagues/reviewers/etc. Furthermore,
information such as relative contributions of the authors may be added here
(if any).
\end{leftbar}


%% -- Bibliography -------------------------------------------------------------
%% - References need to be provided in a .bib BibTeX database.
%% - All references should be made with \cite, \citet, \citep, \citealp etc.
%%   (and never hard-coded). See the FAQ for details.
%% - JSS-specific markup (\proglang, \pkg, \code) should be used in the .bib.
%% - Titles in the .bib should be in title case.
%% - DOIs should be included where available.

\bibliography{D:/DocumentationArcheo/biblio10}


%% -- Appendix (if any) --------------------------------------------------------
%% - After the bibliography with page break.
%% - With proper section titles and _not_ just "Appendix".

\newpage

\begin{appendix}

\section{More technical details} \label{app:technical}

\begin{leftbar}
Appendices can be included after the bibliography (with a page break). Each
section within the appendix should have a proper section title (rather than
just \emph{Appendix}).

For more technical style details, please check out JSS's style FAQ at
\url{https://www.jstatsoft.org/pages/view/style#frequently-asked-questions}
which includes the following topics:
\begin{itemize}
  \item Title vs.\ sentence case.
  \item Graphics formatting.
  \item Naming conventions.
  \item Turning JSS manuscripts into \proglang{R} package vignettes.
  \item Trouble shooting.
  \item Many other potentially helpful details\dots
\end{itemize}
\end{leftbar}


\section[Using BibTeX]{Using \textsc{Bib}{\TeX}} \label{app:bibtex}

\begin{leftbar}
References need to be provided in a \textsc{Bib}{\TeX} file (\code{.bib}). All
references should be made with \verb|\cite|, \verb|\citet|, \verb|\citep|,
\verb|\citealp| etc.\ (and never hard-coded). This commands yield different
formats of author-year citations and allow to include additional details (e.g.,
pages, chapters, \dots) in brackets. In case you are not familiar with these
commands see the JSS style FAQ for details.

Cleaning up \textsc{Bib}{\TeX} files is a somewhat tedious task -- especially
when acquiring the entries automatically from mixed online sources. However,
it is important that informations are complete and presented in a consistent
style to avoid confusions. JSS requires the following format.
\begin{itemize}
  \item JSS-specific markup (\verb|\proglang|, \verb|\pkg|, \verb|\code|) should
    be used in the references.
  \item Titles should be in title case.
  \item Journal titles should not be abbreviated and in title case.
  \item DOIs should be included where available.
  \item Software should be properly cited as well. For \proglang{R} packages
    \code{citation("pkgname")} typically provides a good starting point.
\end{itemize}
\end{leftbar}

\end{appendix}

%% -----------------------------------------------------------------------------


\end{document}
